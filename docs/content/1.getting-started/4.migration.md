---
title: Migration Guide 
description: Learn how to migrate @nuxtjs/supabase to take advantage of JWT signing keys support
navigation:
  title: Migration
---

This guide will help you migrate from `v1.x` to `v2.x`, which introduces support for Supabase's new JWT signing keys.

::tip{to="https://supabase.com/blog/jwt-signing-keys"}
You can find a complete blog post about this migration in this **Supabase blog**
::

## What are JWT Signing Keys?

Supabase has introduced a major security improvement by moving from symmetric to asymmetric JWT (JSON Web Token) signing. This change addresses critical security and performance issues in how your applications handle authentication.

### The Problem with Old Keys (Symmetric)
Previously, Supabase used a single shared secret key for both creating and verifying tokens. This meant your app had to constantly call `supabase.auth.getUser()` to check if sessions were valid, creating network delays calling the Supabase Auth server.

### The Solution: JWT Signing Keys (Asymmetric)
The new system uses two separate keys: a private key (kept secure by Supabase) for creating tokens, and a public key (safe to share in your application) for verifying them. Your application can now verify user sessions locally without contacting Supabase servers, making it faster and more reliable. This new key is named as `publishable key` on Supabase.

### Key Benefits
This upgrade eliminates authentication bottlenecks, improves security, and makes your applications work better at the edge (no extra calls to the Supabase Auth server).

::note{to="https://supabase.com/blog/jwt-signing-keys"}
Read the full technical explanation in the official Supabase blog post.
::

##  Changes in environment variables

**Remaining key** → **`SUPABASE_KEY`** is now storing the `publishable key` instead of the `anon key`

**New key** → **`SUPABASE_SECRET_KEY`** is now storing the `secret key` of your Supabase project

**Deprecated key** → **`SUPABASE_SERVICE_KEY`** was previously storing the `service_role key` but is now deprecated in favor of `SUPABASE_SECRET_KEY`


## Migration Steps

**Good news** ☀️ Everything will continue to work as-is with your existing `SUPABASE_KEY` (aka `anon key`). No migration is required. 

If you're using `SUPABASE_SERVICE_KEY` to bypass Row Level Security, you will face a deprecation warning but it will still work.

::warning{to="https://supabase.com/blog/jwt-signing-keys"}
However, we highly recommend you to enable JWT signing keys in your Supabase project and use your publishable key as `SUPABASE_KEY` and your secret key as `SUPABASE_SECRET_KEY`.
::

### Step 1: Enable JWT Signing Keys in Supabase Dashboard

Before migrating your environment variables, you need to enable JWT signing keys and thus create your JWT and API keys in your Supabase project:

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/rwnOal_xRtM"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

::tip
**Watch this video tutorial** from **6:20 to 12:20** to understand how to enable JWT signing keys in your Supabase dashboard and get your new secret key.
::

### Step 2: Use your new keys in your `.env` file

```bash [.env]
SUPABASE_KEY=<your_publishable_key>
SUPABASE_SECRET_KEY=<your_secret_key>
```

## Important: `useSupabaseUser` Type Changes

With JWT signing keys, `useSupabaseUser` now returns **JWT claims** instead of the full **User object**. This change improves performance by avoiding unnecessary API calls.

### What Changed

**Before (v1.x):** `useSupabaseUser` returned the full `User` object from `auth.getUser()`
**After (v2.x):** `useSupabaseUser` returns `Claims` object from `auth.getClaims()`

### The Difference

#### `auth.getUser()` - Full User Object
```ts
const { data: { user }, error } = await supabase.auth.getUser()

console.log(user)
/*
{
  id: "uuid",
  aud: "authenticated", 
  role: "authenticated",
  email: "test@example.com",
  phone: null,
  app_metadata: { provider: "email", providers: ["email"] },
  user_metadata: { full_name: "Jane Doe" },
  identities: [...],
  created_at: "...",
  updated_at: "..."
}
*/
```

#### `auth.getClaims()` - JWT Claims Only
```ts
const { data: { claims }, error } = await supabase.auth.getClaims()

console.log(claims)
/*
{
  sub: "uuid",
  aud: "authenticated",
  role: "authenticated", 
  exp: 1695678901,
  email: "test@example.com"
  // No user_metadata, app_metadata, or identities
}
*/
```

### Migration Impact

**If you need the full User object**, you'll need to explicitly call `auth.getUser()`:

```ts
// Before (v1.x)
const user = useSupabaseUser()
console.log(user.value?.user_metadata) // ✅ Available

// After (v2.x) 
const user = useSupabaseUser() // Now returns Claims
console.log(user.value?.user_metadata) // ❌ undefined

// Solution: Get full user when needed
const client = useSupabaseClient()
const { data: { user } } = await client.auth.getUser()
console.log(user?.user_metadata) // ✅ Available
```

**If you only need basic info** (id, email, role), no changes required:

```ts
const user = useSupabaseUser()
console.log(user.value?.sub) // ✅ Still works (was 'id' before)
console.log(user.value?.email) // ✅ Still works
console.log(user.value?.role) // ✅ Still works
```

::tip
The `sub` claim in JWT corresponds to the user's `id`. Use `user.value?.sub` instead of `user.value?.id`.
::

## Backward Compatibility

Everything will continue to work as before in your project but you won't take advantage of the new JWT signing keys performance and security benefits.

- ✅ **Existing `anon` key in `SUPABASE_KEY`** continues to work exactly as before without any code changes
- ✅ **Existing `service_role` key in `SUPABASE_SERVICE_KEY`** still works but shows deprecation warnings
- ✅ **Client-side operations**: All composables (`useSupabaseClient`, `useSupabaseSession`, etc.) work unchanged
- ⚠️ **`useSupabaseUser`**: Now returns JWT claims instead of full User object (see above)
